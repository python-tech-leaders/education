## Iterator & generator

Ссылка на документацию: https://docs.python.org/3/glossary.html#term-iterator

https://docs.python.org/3/library/stdtypes.html#typeiter

https://docs.python.org/3/library/itertools.html

Итерирование — это взаимодействие с неким объектом, поддерживающим протокол итерации.

Протокол итерации требует от объекта быть итерируемым (iterable), т.е. иметь специальный метод `__iter__`. Если у iterable-объекта вызвать метод `__iter__`, то метод должен вернуть новый специальный объект — так называемый итератор (iterator). А итератор, в свою очередь, должен иметь метод `__next__`. Рассмотрим пример — итерирование списка. Список — итерируемый, поэтому нам подходит. Итак, создадим список и итератор для него:
```
>>> l = [1,2,3,5,8,11]
>>> i = iter(l)
>>> i
<list_iterator object at 0x7f517843a240>
```
Функция iter на самом деле просто вызывает у списка соответствующий метод `__iter__`.
Теперь у нас есть итератор i, попробуем повызывать у него метод `__next__` как напрямую, так и с помощью более удобной функции next:
```
>>> i.__next__()
1
>>> i.__next__()
2
>>> next(i)
3
>>> next(i)
5
```
Как мы видим, при каждом вызове метод возвращает очередной элемент исходного списка. А между вызовами он помнит свою позицию в списке.
Когда итератор достигает конца исходного списка, последующий вызов next приводит к возбуждению исключения `StopIteration`.\
Те средства языка, которые работают на основе протокола итерации, знают, как реагировать на это конкретное исключение. Например, цикл `for` "молча" завершает работу.\
Теперь мы представляем, как на самом деле работает цикл `for`. Он получает у iterable объекта новый итератор, а затем вызывает у итератора метод `__next__` до тех пор, пока не будет выброшено исключение `StopIteration`.\

### Цикл `for` и итераторы
Что же будет, если сначала получить итератор, а потом передать его циклу for? Такое возможно, ведь цикл `for` понимает, что можно сразу начать вызывать `__next__`.

Давайте напишем функцию, ищущую в цикле первую строку, длина которой больше пяти символов:
```
def search_long_string(source):
    for item in source:
        if len(item) >= 5:
            return item
```
А теперь создадим список, содержащий несколько подходящих строк, и запустим функцию для этого списка пару раз:
```
>>> animals = ['cat', 'mole', 'tiger', 'lion', 'camel']
>>> search_long_string(animals)
'tiger'
>>> search_long_string(animals)
'tiger'
```
Функция оба раза вернула одну и ту же строку, ведь мы передали в неё iterable, а значит цикл `for` создавал каждый раз новый итератор.

Но можно создадать итератор самим и передать в функцию уже его:
```
>>> animals = ['cat', 'mole', 'tiger', 'lion', 'camel']
>>> cursor = iter(animals)
>>> search_long_string(cursor)
'tiger'
>>> search_long_string(cursor)
'camel'
>>> search_long_string(cursor)
>>> search_long_string(cursor)
>>>
```
Итератор запомнил состояние между вызовами функций, и мы нашли оба длинных слова. Последующие вызовы функции не вернули ничего, потому что итератор дошёл до конца (и запомнил это).

### Генераторы
https://docs.python.org/3/glossary.html#term-generator

В Python не только коллекции являются iterable. Ещё существуют генераторы (generators). Генератор — это iterable, элементы которого не хранятся в нём, но создаются по мере необходимости. Для примера возьмём генератор `range`. Вот как он работает:
```
>>> numbers = range(1, 5)
>>> for n in numbers:
...     print(n)
...
1
2
3
4
>>> list(numbers)
[1, 2, 3, 4]
```
Здесь `range` генерирует последовательность чисел от 1 до (но не включая) 5 с шагом 1. Цикл `for` итерирует числа. Затем используем функцию `list`, чтобы получить список — эта функция может принять в качестве единственного аргумента iterable или iterator, элементы которого сложит во вновь созданный список.

`range` представляет собой перезапускаемый генератор. Для такого генератора можно создавать сколько угодно итераторов, и для каждого из них значения будут генерироваться заново.

Существуют и не перезапускаемые генераторы. Эти при вызове метода `__iter__` всегда возвращают один и тот же итератор. Поэтому по значениям такого генератора можно пройтись только один раз. Примером такого генератора является enumerate:
```
>>> l = enumerate("asdf")
>>> list(l)
[(0, 'a'), (1, 's'), (2, 'd'), (3, 'f')]
>>> list(l)
[]
```
Вторая попытка проитерировать объект в переменной `l` ничего не даёт, т.к. генератор уже отработал один проход.

А вот ещё один встроенный генератор — `zip`. Этот генератор принимает на входе несколько iterable или iterators и поэлементно группирует в кортежи:
```
>>> keys = ["foo", "bar", "baz"]
>>> values = [1, 2, 3, 4]
>>> for k, v in zip(keys, values):
...     print(k, "=", v)
...
foo = 1
bar = 2
baz = 3
>>> z = zip(range(10), "hello", [True, False])
>>> list(z)
[(0, 'h', True), (1, 'e', False)]
>>> list(z)
[]
```
Пример демонстрирует два момента:

zip — не перезапускаемый,\
zip — перестаёт генерировать кортежи, как только заканчиваются элементы в любом из источников.

### Пример

Реализуем функцию, которая возвращает индекс первого элемента последовательности, равного заданному значению. Здесь уместно использовать генератор enumerate:

```
def find_index(value, items):
    for index, item in enumerate(items):
        if item == value:
            return index
```

Затем реализуем функцию, которая возвращает индекс __второго__ подходящего элемента в последовательности. Если подходящих элементов в последовательности меньше двух или же последовательность пуста, возвращается None.
```
>>> find_second_index('b', 'bob')
2
>>> find_second_index('a', 'cat') is None
True
```
Здесь используем функцию iter, которая вызывает у последовательности метод `__iter__` и запоминает место, где остановилась:
```
def find_second_index(value, items):
    iterator = iter(items)
    first = find_index(value, iterator)
    second = find_index(value, iterator)
    if second is not None:
        return first + second + 1
```